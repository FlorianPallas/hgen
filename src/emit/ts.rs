use crate::lang::{map::OrderedHashMap, schema::*};

pub fn emit_schema(file_name: &str, schema: &Schema) -> String {
    let mut output = String::new();

    // emit header
    output.push_str("// AUTOGENERATED FILE - DO NOT EDIT\n");
    output.push_str("\n");

    // emit models
    output.push_str(
        &schema
            .models
            .iter()
            .map(|(name, def)| emit_model(name, def, file_name))
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("\n");

    // emit consumers
    output.push_str(
        &schema
            .services
            .iter()
            .map(|(name, shape)| emit_consumer(name, shape))
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("\n");

    // emit providers
    output.push_str(
        &schema
            .services
            .iter()
            .map(|(name, def)| emit_provider(name, def))
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("\n");

    // emit metadata
    output.push_str("// prettier-ignore\n");
    output.push_str(&format!(
        "export const $schema = {}",
        reflect_schema(schema)
    ));

    output
}

fn emit_provider(name: &str, service: &Service) -> String {
    let mut output = String::new();

    output.push_str(&format!("export interface {}Provider ", name));
    output.push_str("{\n");
    output.push_str(
        &service
            .methods
            .iter()
            .map(|(name, def)| emit_provider_method(name, def))
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("}\n");

    output
}

fn emit_provider_method(name: &str, method: &Annotated<ServiceMethod>) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "  {}({}): Promise<{}>;\n",
        name,
        method
            .inner
            .inputs
            .iter()
            .map(|(name, shape)| format!("{}: {}", name, emit_shape(shape)))
            .collect::<Vec<_>>()
            .join(", "),
        match method.inner.output {
            Some(ref shape) => emit_shape(shape),
            None => "void".to_owned(),
        }
    ));

    output
}

fn emit_consumer(name: &str, service: &Service) -> String {
    let mut output = String::new();

    output.push_str(&format!("export class {}Consumer ", name));
    output.push_str("{\n");
    output.push_str(
        "  constructor(\n    protected request: (method: string, inputs: any) => Promise<any>\n  ) {}\n\n",
    );
    output.push_str(
        &service
            .methods
            .iter()
            .map(|(name, def)| emit_consumer_method(name, def))
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("}\n");

    output
}

fn emit_consumer_method(name: &str, method: &Annotated<ServiceMethod>) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "  {}({}): Promise<{}> {{\n",
        name,
        method
            .inner
            .inputs
            .iter()
            .map(|(name, shape)| format!("{}: {}", name, emit_shape(shape)))
            .collect::<Vec<_>>()
            .join(", "),
        match method.inner.output {
            Some(ref shape) => emit_shape(shape),
            None => "void".to_owned(),
        }
    ));
    output.push_str(&format!(
        "    return this.request(\"{}\", {{ {} }});\n",
        name,
        method
            .inner
            .inputs
            .iter()
            .map(|(name, _)| *name)
            .collect::<Vec<_>>()
            .join(", ")
    ));
    output.push_str("  }\n");

    output
}

fn reflect_schema(schema: &Schema) -> String {
    let mut output = String::new();

    output.push_str("{");

    // emit models
    output.push_str(&format!(
        "models:{{{}}}",
        schema
            .models
            .iter()
            .map(|(name, def)| reflect_model(name, def))
            .collect::<Vec<_>>()
            .join(",")
    ));

    // emit services
    output.push_str(",");
    output.push_str(&format!(
        "services:{{{}}}",
        schema
            .services
            .iter()
            .map(|(name, def)| reflect_service(name, def))
            .collect::<Vec<_>>()
            .join(",")
    ));

    output.push_str("} as const;");

    output
}

fn emit_model(name: &str, def: &Model, file_name: &str) -> String {
    match def {
        Model::Struct(s) => emit_struct(name, s),
        Model::Enum(e) => emit_enum(name, e),
        Model::Alias(a) => emit_alias(name, a),
        Model::External(_) => format!("import {{ {} }} from './{}.external';\n", name, file_name),
    }
}

fn reflect_model(name: &str, def: &Model) -> String {
    match def {
        Model::Struct(inner) => format!("{}:{{{}}}", name, reflect_struct(inner)),
        Model::Enum(inner) => format!("{}:{{{}}}", name, reflect_enum(inner)),
        Model::Alias(inner) => {
            format!(
                "{}:{{type:'alias',inner:{{{}}}}}",
                name,
                reflect_annotated_shape(&inner.shape)
            )
        }
        Model::External(inner) => {
            format!(
                "{}:{{type:'external',inner:{{{}}}}}",
                name,
                reflect_annotated_shape(&inner.shape)
            )
        }
    }
}

fn reflect_service(name: &str, def: &Service) -> String {
    let mut output = String::new();

    output.push_str(&format!("{}:{{", name));
    output.push_str("type:'service',");

    output.push_str(&format!(
        "methods:{{{}}}",
        def.methods
            .iter()
            .map(|(name, def)| reflect_method(name, def))
            .collect::<Vec<_>>()
            .join(",")
    ));

    output.push_str("}");

    output
}

fn reflect_method(name: &str, def: &Annotated<ServiceMethod>) -> String {
    format!(
        "{}:{{inputs:{{{}}},output:{{{}}},metadata:{{{}}}}}",
        name,
        def.inner
            .inputs
            .iter()
            .map(|(name, shape)| format!("{}:{{{}}}", name, reflect_shape(shape)))
            .collect::<Vec<_>>()
            .join(","),
        match def.inner.output {
            Some(ref shape) => reflect_shape(shape),
            None => "".to_owned(),
        },
        reflect_metadata(&def.metadata),
    )
}

fn reflect_struct(def: &Struct) -> String {
    format!(
        "type:'struct',fields:{{{}}}",
        def.fields
            .iter()
            .map(|(name, shape)| format!("{}:{{{}}}", name, reflect_annotated_shape(shape)))
            .collect::<Vec<_>>()
            .join(",")
    )
}

fn reflect_enum(def: &Enum) -> String {
    format!(
        "type:'enum',fields:{{{}}}",
        def.fields
            .iter()
            .map(|value| format!("{}:''", value))
            .collect::<Vec<_>>()
            .join(",")
    )
}

fn reflect_shape(shape: &Shape) -> String {
    match shape {
        Shape::Bool => "type:'bool'".to_owned(),
        Shape::Int8 => "type:'int8'".to_owned(),
        Shape::Int16 => "type:'int16'".to_owned(),
        Shape::Int32 => "type:'int32'".to_owned(),
        Shape::Int64 => "type:'int64'".to_owned(),
        Shape::Float32 => "type:'float32'".to_owned(),
        Shape::Float64 => "type:'float64'".to_owned(),
        Shape::String => "type:'string'".to_owned(),
        Shape::Nullable(inner) => {
            format!("type:'nullable',inner:{{{}}}", reflect_shape(inner))
        }
        Shape::List(inner) => format!("type:'list',inner:{{{}}}", reflect_shape(inner)),
        Shape::Map(key, value) => {
            format!(
                "type:'map',key:{{{}}},value:{{{}}}",
                reflect_shape(key),
                reflect_shape(value)
            )
        }
        Shape::Reference(inner) => format!("type:'reference',name:'{}'", inner),
    }
}

fn reflect_annotated_shape(shape: &Annotated<Shape>) -> String {
    format!(
        "{},metadata:{{{}}}",
        reflect_shape(&shape.inner),
        reflect_metadata(&shape.metadata),
    )
}

fn reflect_metadata(metadata: &OrderedHashMap<&str, Literal>) -> String {
    metadata
        .iter()
        .map(|(k, v)| format!("{}:{}", k, reflect_literal(v)))
        .collect::<Vec<_>>()
        .join(",")
}

fn reflect_literal(literal: &Literal) -> String {
    match literal {
        Literal::Bool(inner) => if *inner { "true" } else { "false" }.to_owned(),
        Literal::String(inner) => format!("'{}'", inner),
        Literal::Int(inner) => inner.to_string(),
        Literal::Float(inner) => inner.to_string(),
        Literal::Array(inner) => format!(
            "[{}]",
            inner
                .iter()
                .map(reflect_literal)
                .collect::<Vec<_>>()
                .join(",")
        ),
        Literal::Object(inner) => format!(
            "{{{}}}",
            inner
                .iter()
                .map(|(k, v)| format!("{}:{}", k, reflect_literal(v)))
                .collect::<Vec<_>>()
                .join(",")
        ),
    }
}

fn emit_alias(name: &str, alias: &Alias) -> String {
    format!(
        "export type {} = {};\n",
        name,
        emit_shape(&alias.shape.inner)
    )
}

fn emit_enum(name: &str, message: &Enum) -> String {
    let mut output = String::new();

    output.push_str(&format!("export enum {} ", name));
    output.push_str("{\n");
    message.fields.iter().for_each(|name| {
        output.push_str(&format!("  {} = '{}',\n", name, name));
    });
    output.push_str("}\n");

    output
}

fn emit_struct(name: &str, message: &Struct) -> String {
    let mut output = String::new();

    output.push_str(&format!("export class {} ", name));
    output.push_str("{\n");
    message.fields.iter().for_each(|(name, shape)| {
        output.push_str(&format!("  {}: {};\n", name, emit_shape(&shape.inner)));
    });
    output.push_str("}\n");

    output
}

fn emit_shape(shape: &Shape) -> String {
    match shape {
        Shape::Bool { .. } => "boolean".to_owned(),
        Shape::Int8 { .. } => "number".to_owned(),
        Shape::Int16 { .. } => "number".to_owned(),
        Shape::Int32 { .. } => "number".to_owned(),
        Shape::Int64 { .. } => "bigint".to_owned(),
        Shape::Float32 { .. } => "number".to_owned(),
        Shape::Float64 { .. } => "number".to_owned(),
        Shape::String { .. } => "string".to_owned(),
        Shape::Nullable(inner) => format!("({} | null)", emit_shape(inner)),
        Shape::List(inner) => format!("({}[])", emit_shape(inner)),
        Shape::Map(key, value) => format!("Map<{}, {}>", emit_shape(key), emit_shape(value)),
        Shape::Reference(name) => (*name).to_owned(),
    }
}
