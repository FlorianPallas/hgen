use crate::lang::schema::*;

pub fn emit_schema(module_name: &str, schema: &Schema) -> String {
    let mut output = String::new();

    // emit header
    output.push_str("// AUTOGENERATED FILE - DO NOT EDIT\n");
    output.push_str("\n");
    output.push_str(&format!("import '{}.external.dart';\n", module_name));
    output.push_str("\n");

    // emit models
    output.push_str(
        &schema
            .models
            .iter()
            .map(|m| emit_model(schema, m))
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("\n");

    output
}

fn emit_alias(schema: &Schema, alias: &Alias) -> String {
    format!(
        "typedef {} = {};\n",
        alias.name,
        emit_type(schema, &alias.def)
    )
}

fn emit_type(schema: &Schema, def: &Type) -> String {
    let mut output = String::new();

    output.push_str(&emit_shape(schema, &def.shape));
    if !def.data.is_empty() {
        output.push_str(" & ");
    }

    output
}

fn emit_model(schema: &Schema, model: &Model) -> String {
    match model {
        Model::Struct(s) => emit_struct(schema, s),
        Model::Enum(e) => emit_enum(e),
        Model::Alias(a) => emit_alias(schema, a),
        Model::External(_) => "".to_owned(),
    }
}

fn emit_enum(def: &Enum) -> String {
    let mut output = String::new();

    output.push_str(&format!("enum {} ", &def.name));
    output.push_str("{\n");

    // Emit variants
    def.values.iter().for_each(|name| {
        output.push_str(&format!("  {},\n", name));
    });
    output.push_str("}\n");

    output
}

fn emit_struct(schema: &Schema, def: &Struct) -> String {
    let mut output = String::new();

    output.push_str(&format!("class {} ", &def.name));
    output.push_str("{\n");

    // Emit fields
    def.fields.iter().for_each(|(name, field)| {
        output.push_str(&format!(
            "  {} {};\n",
            emit_shape(schema, &field.shape),
            name
        ));
    });
    output.push_str("\n");

    // Emit constructor
    output.push_str(format!("  {}({{\n", &def.name).as_str());
    def.fields.iter().for_each(|(name, field)| {
        let optional = match &field.shape {
            Shape::Nullable(_) => true,
            _ => false,
        };

        output.push_str(&format!(
            "    {}this.{},\n",
            if optional { "" } else { "required " },
            name,
        ));
    });
    output.push_str("  });\n");
    output.push_str("\n");

    // emit fromJSON
    output.push_str("  factory ");
    output.push_str(&def.name);
    output.push_str(".fromJSON(Map<String, dynamic> json) => ");
    output.push_str(&def.name);
    output.push_str("(\n");
    output.push_str(
        &def.fields
            .iter()
            .map(|(name, def)| {
                format!(
                    "    {}: json['{}'] as {}",
                    name,
                    name,
                    emit_shape(schema, &def.shape)
                )
            })
            .collect::<Vec<_>>()
            .join(",\n"),
    );
    output.push_str("\n  );\n");
    output.push_str("\n");

    // emit toJSON
    output.push_str("  Map<String, dynamic> toJSON() => <String, dynamic>{\n");
    output.push_str(
        &def.fields
            .iter()
            .map(|(name, _)| format!("    '{}': {}", name, name))
            .collect::<Vec<_>>()
            .join(",\n"),
    );
    output.push_str("\n  };\n");
    output.push_str("\n");

    // TODO: emit utility methods
    // toJSON
    // fromJSON
    // toString
    // equals
    // hashCode
    // ...

    output.push_str("}\n");

    output
}

fn emit_shape(schema: &Schema, shape: &Shape) -> String {
    match shape {
        Shape::Primitive(primitive) => match primitive {
            Primitive::Bool { .. } => "bool".to_owned(),
            Primitive::Int32 { .. } => "int".to_owned(),
            Primitive::Int64 { .. } => "int".to_owned(),
            Primitive::Float32 { .. } => "double".to_owned(),
            Primitive::Float64 { .. } => "double".to_owned(),
            Primitive::String { .. } => "String".to_owned(),
        },
        Shape::Nullable(inner) => format!("{}?", emit_shape(schema, inner)),
        Shape::List(inner) => format!("List<{}>", emit_shape(schema, inner)),
        Shape::Set(inner) => format!("Set<{}>", emit_shape(schema, inner)),
        Shape::Map(key, value) => format!(
            "Map<{}, {}>",
            emit_shape(schema, key),
            emit_shape(schema, value)
        ),
        Shape::Reference(name) => schema.resolve(&name).unwrap().to_owned(),
    }
}
