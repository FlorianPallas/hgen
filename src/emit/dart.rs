use crate::lang::schema::*;

pub fn emit_schema(module_name: &str, schema: &Schema) -> String {
    let mut output = String::new();

    // emit header
    output.push_str("// AUTOGENERATED FILE - DO NOT EDIT\n");
    output.push_str("\n");
    output.push_str(&format!("import '{}.external.dart';\n", module_name));
    output.push_str("\n");

    // emit models
    output.push_str(
        &schema
            .models
            .iter()
            .map(|m| emit_model(schema, m))
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("\n");

    // emit serialization
    output.push_str(
        &schema
            .models
            .iter()
            .map(|m| serialize_model(schema, m))
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("\n");
    output.push_str("\n");

    // emit deserialization
    output.push_str(
        &schema
            .models
            .iter()
            .map(|m| deserialize_model(schema, m))
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("\n");

    output
}

fn emit_alias(schema: &Schema, alias: &Alias) -> String {
    format!(
        "typedef {} = {};\n",
        alias.name,
        emit_shape(schema, &alias.def.shape)
    )
}

fn emit_model(schema: &Schema, model: &Model) -> String {
    match model {
        Model::Struct(s) => emit_struct(schema, s),
        Model::Enum(e) => emit_enum(e),
        Model::Alias(a) => emit_alias(schema, a),
        Model::External(_) => "".to_owned(),
    }
}

fn emit_enum(def: &Enum) -> String {
    let mut output = String::new();

    output.push_str(&format!("enum {} ", &def.name));
    output.push_str("{\n");

    // Emit variants
    output.push_str(
        &def.values
            .iter()
            .map(|v| format!("  {}", v))
            .collect::<Vec<_>>()
            .join(",\n"),
    );
    output.push_str(";\n");
    output.push_str("\n");

    // Emit toJson method
    output.push_str(&format!(
        "  String toJson() => ${}ToJson(this);\n",
        def.name
    ));

    // Emit fromJson method
    output.push_str(&format!(
        "  factory {}.fromJson(String json) => ${}FromJson(json);\n",
        def.name, def.name
    ));

    output.push_str("}\n");

    output
}

fn emit_struct(schema: &Schema, def: &Struct) -> String {
    let mut output = String::new();

    output.push_str(&format!("class {} ", &def.name));
    output.push_str("{\n");

    // Emit fields
    def.fields.iter().for_each(|(name, field)| {
        output.push_str(&format!(
            "  {} {};\n",
            emit_shape(schema, &field.shape),
            name
        ));
    });
    output.push_str("\n");

    // Emit constructor
    output.push_str(format!("  {}({{\n", &def.name).as_str());
    def.fields.iter().for_each(|(name, field)| {
        let optional = match &field.shape {
            Shape::Nullable(_) => true,
            _ => false,
        };

        output.push_str(&format!(
            "    {}this.{},\n",
            if optional { "" } else { "required " },
            name,
        ));
    });
    output.push_str("  });\n");
    output.push_str("\n");

    // Emit toJson method
    output.push_str(&format!(
        "  Map<String, dynamic> toJson() => ${}ToJson(this);\n",
        def.name
    ));

    // Emit fromJson method
    output.push_str(&format!(
        "  factory {}.fromJson(Map<String, dynamic> json) => ${}FromJson(json);\n",
        def.name, def.name
    ));

    output.push_str("}\n");

    output
}

fn emit_shape(schema: &Schema, shape: &Shape) -> String {
    match shape {
        Shape::Primitive(primitive) => match primitive {
            Primitive::Bool { .. } => "bool".to_owned(),
            Primitive::Int32 { .. } => "int".to_owned(),
            Primitive::Int64 { .. } => "int".to_owned(),
            Primitive::Float32 { .. } => "double".to_owned(),
            Primitive::Float64 { .. } => "double".to_owned(),
            Primitive::String { .. } => "String".to_owned(),
        },
        Shape::Nullable(inner) => format!("{}?", emit_shape(schema, inner)),
        Shape::List(inner) => format!("List<{}>", emit_shape(schema, inner)),
        Shape::Set(inner) => format!("Set<{}>", emit_shape(schema, inner)),
        Shape::Map(key, value) => format!(
            "Map<{}, {}>",
            emit_shape(schema, key),
            emit_shape(schema, value)
        ),
        Shape::Reference(name) => schema.resolve(&name).unwrap().to_owned(),
    }
}

fn serialize_model(schema: &Schema, model: &Model) -> String {
    match model {
        Model::Struct(inner) => serialize_struct(schema, inner),
        Model::Enum(inner) => serialize_enum(inner),
        Model::Alias(inner) => serialize_alias(schema, inner),
        Model::External(inner) => format!(
            "/* Map<String, dynamic> ${}ToJson({} instance) => ? */",
            inner.name, inner.name
        ),
    }
}

fn deserialize_model(schema: &Schema, model: &Model) -> String {
    match model {
        Model::Struct(inner) => deserialize_struct(schema, inner),
        Model::Enum(inner) => deserialize_enum(inner),
        Model::Alias(inner) => deserialize_alias(schema, inner),
        Model::External(inner) => format!(
            "/* {} ${}FromJson(Map<String, dynamic> json) => ? */",
            inner.name, inner.name
        ),
    }
}

fn serialize_struct(schema: &Schema, def: &Struct) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "Map<String, dynamic> ${}ToJson({} instance) => <String, dynamic>{{",
        def.name, def.name
    ));
    output.push_str(
        &def.fields
            .iter()
            .map(|(name, field)| {
                format!(
                    "'{}':{}",
                    name,
                    serialize_shape(schema, &format!("instance.{}", name), &field.shape)
                )
            })
            .collect::<Vec<_>>()
            .join(","),
    );
    output.push_str("};");

    output
}

fn serialize_enum(def: &Enum) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "dynamic ${}ToJson({} instance)=>",
        def.name, def.name
    ));
    output.push_str("switch(instance){");
    output.push_str(
        &def.values
            .iter()
            .map(|v| format!("{}.{}=>'{}'", def.name, v, v))
            .collect::<Vec<_>>()
            .join(","),
    );
    output.push_str("};");

    output
}

fn deserialize_enum(def: &Enum) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "{} ${}FromJson(String value)=>",
        def.name, def.name
    ));
    output.push_str("switch(value){");
    output.push_str(
        &def.values
            .iter()
            .map(|v| format!("'{}'=>{}.{},", v, def.name, v))
            .collect::<Vec<_>>()
            .join(""),
    );
    output.push_str(&format!("_=>throw'Unknown {} value: $value'", def.name));
    output.push_str("};");

    output
}

fn serialize_alias(schema: &Schema, alias: &Alias) -> String {
    format!(
        "dynamic ${}ToJson({} instance) => {};",
        alias.name,
        alias.name,
        serialize_shape(schema, "instance", &alias.def.shape)
    )
}

fn deserialize_alias(schema: &Schema, alias: &Alias) -> String {
    format!(
        "{} ${}FromJson(dynamic json) => {};",
        alias.name,
        alias.name,
        deserialize_shape(schema, "json", &alias.def.shape)
    )
}

fn deserialize_struct(schema: &Schema, def: &Struct) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "{} ${}FromJson(Map<String,dynamic>json)=>{}(",
        &def.name, &def.name, &def.name
    ));
    output.push_str(
        &def.fields
            .iter()
            .map(|(name, field)| {
                format!(
                    "{}:{}",
                    name,
                    deserialize_shape(schema, &format!("json['{}']", name), &field.shape)
                )
            })
            .collect::<Vec<_>>()
            .join(","),
    );
    output.push_str(");");

    output
}

fn serialize_shape(schema: &Schema, name: &str, shape: &Shape) -> String {
    match shape {
        Shape::Nullable(inner) => format!(
            "{} == null ? null : {}",
            name,
            serialize_shape(
                schema,
                &format!("{} as {}", name, emit_shape(schema, inner)),
                inner
            ),
        ),
        Shape::Reference(type_name) => {
            format!("${}ToJson({})", schema.resolve(&type_name).unwrap(), name)
        }
        _ => format!("{}", name),
    }
}

fn deserialize_shape(schema: &Schema, field_name: &str, shape: &Shape) -> String {
    match shape {
        Shape::Primitive(_) => format!("{} as {}", field_name, emit_shape(schema, shape)),
        Shape::Nullable(inner) => format!(
            "{} == null ? null : {} as {}",
            field_name,
            field_name,
            emit_shape(schema, inner)
        ),
        Shape::List(inner) => format!(
            "({} as List<dynamic>).map((e) => {}).toList()",
            field_name,
            deserialize_shape(schema, "e", inner)
        ),
        Shape::Set(inner) => format!(
            "({} as List<dynamic>).map((e) => {}).toSet()",
            field_name,
            deserialize_shape(schema, "e", inner)
        ),
        Shape::Map(key, value) => format!(
            "({} as Map<String,dynamic>).map((k,v) => MapEntry({},{}))",
            field_name,
            deserialize_shape(schema, "k", key),
            deserialize_shape(schema, "v", value),
        ),
        Shape::Reference(name) => format!(
            "${}FromJson({})",
            schema.resolve(&name).unwrap(),
            field_name
        ),
    }
}
