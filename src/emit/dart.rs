use crate::lang::schema::*;

pub fn emit_schema(module_name: &str, schema: &Schema) -> String {
    let mut output = String::new();

    // emit header
    output.push_str("// AUTOGENERATED FILE - DO NOT EDIT\n");
    output.push_str("\n");
    output.push_str(&format!("import '{}.external.dart';\n", module_name));
    output.push_str("\n");

    // emit models
    output.push_str(
        &schema
            .models
            .iter()
            .map(emit_model)
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("\n");

    // emit serialization
    output.push_str(
        &schema
            .models
            .iter()
            .map(serialize_model)
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("\n");
    output.push_str("\n");

    // emit deserialization
    output.push_str(
        &schema
            .models
            .iter()
            .map(deserialize_model)
            .collect::<Vec<_>>()
            .join("\n"),
    );
    output.push_str("\n");

    output
}

fn emit_alias(alias: &Alias) -> String {
    format!(
        "typedef {} = {};\n",
        alias.name,
        emit_shape(&alias.def.shape)
    )
}

fn emit_model(model: &Model) -> String {
    match model {
        Model::Struct(s) => emit_struct(s),
        Model::Enum(e) => emit_enum(e),
        Model::Alias(a) => emit_alias(a),
        // no need to emit external models, they are already imported
        Model::External(_) => "".to_owned(),
    }
}

fn emit_enum(def: &Enum) -> String {
    let mut output = String::new();

    output.push_str(&format!("enum {} ", &def.name));
    output.push_str("{\n");

    // Emit variants
    output.push_str(
        &def.values
            .iter()
            .map(|v| format!("  {}", v))
            .collect::<Vec<_>>()
            .join(",\n"),
    );
    output.push_str(";\n");
    output.push_str("\n");

    // Emit toJson method
    output.push_str(&format!(
        "  String toJson() => ${}ToJson(this);\n",
        def.name
    ));

    // Emit fromJson method
    output.push_str(&format!(
        "  factory {}.fromJson(String json) => ${}FromJson(json);\n",
        def.name, def.name
    ));

    output.push_str("}\n");

    output
}

fn emit_struct(def: &Struct) -> String {
    let mut output = String::new();

    output.push_str(&format!("class {} ", &def.name));
    output.push_str("{\n");

    // Emit fields
    def.fields.iter().for_each(|(name, field)| {
        output.push_str(&format!("  {} {};\n", emit_shape(&field.shape), name));
    });
    output.push_str("\n");

    // Emit constructor
    output.push_str(format!("  {}({{\n", &def.name).as_str());
    def.fields.iter().for_each(|(name, field)| {
        let optional = match &field.shape {
            Shape::Nullable(_) => true,
            _ => false,
        };

        output.push_str(&format!(
            "    {}this.{},\n",
            if optional { "" } else { "required " },
            name,
        ));
    });
    output.push_str("  });\n");
    output.push_str("\n");

    // Emit toJson method
    output.push_str(&format!(
        "  Map<String, dynamic> toJson() => ${}ToJson(this);\n",
        def.name
    ));

    // Emit fromJson method
    output.push_str(&format!(
        "  factory {}.fromJson(Map<String, dynamic> json) => ${}FromJson(json);\n",
        def.name, def.name
    ));

    output.push_str("}\n");

    output
}

fn emit_shape(shape: &Shape) -> String {
    match shape {
        Shape::Primitive(primitive) => match primitive {
            Primitive::Bool { .. } => "bool".to_owned(),
            Primitive::Int32 { .. } => "int".to_owned(),
            Primitive::Int64 { .. } => "int".to_owned(),
            Primitive::Float32 { .. } => "double".to_owned(),
            Primitive::Float64 { .. } => "double".to_owned(),
            Primitive::String { .. } => "String".to_owned(),
        },
        Shape::Nullable(inner) => format!("{}?", emit_shape(inner)),
        Shape::List(inner) => format!("List<{}>", emit_shape(inner)),
        Shape::Set(inner) => format!("Set<{}>", emit_shape(inner)),
        Shape::Map(key, value) => format!("Map<{}, {}>", emit_shape(key), emit_shape(value)),
        Shape::Reference(name) => name.to_owned(),
    }
}

fn serialize_model(model: &Model) -> String {
    match model {
        Model::Struct(inner) => serialize_struct(inner),
        Model::Enum(inner) => serialize_enum(inner),
        Model::Alias(inner) => serialize_alias(inner),
        Model::External(inner) => format!(
            "/* Map<String, dynamic> ${}ToJson({} instance) => ? */",
            inner.name, inner.name
        ),
    }
}

fn deserialize_model(model: &Model) -> String {
    match model {
        Model::Struct(inner) => deserialize_struct(inner),
        Model::Enum(inner) => deserialize_enum(inner),
        Model::Alias(inner) => deserialize_alias(inner),
        Model::External(inner) => format!(
            "/* {} ${}FromJson(Map<String, dynamic> json) => ? */",
            inner.name, inner.name
        ),
    }
}

fn serialize_struct(def: &Struct) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "Map<String, dynamic> ${}ToJson({} instance) => <String, dynamic>{{",
        def.name, def.name
    ));
    output.push_str(
        &def.fields
            .iter()
            .map(|(name, field)| {
                format!(
                    "'{}':{}",
                    name,
                    serialize_shape(&format!("instance.{}", name), &field.shape)
                )
            })
            .collect::<Vec<_>>()
            .join(","),
    );
    output.push_str("};");

    output
}

fn serialize_enum(def: &Enum) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "dynamic ${}ToJson({} instance)=>",
        def.name, def.name
    ));
    output.push_str("switch(instance){");
    output.push_str(
        &def.values
            .iter()
            .map(|v| format!("{}.{}=>'{}'", def.name, v, v))
            .collect::<Vec<_>>()
            .join(","),
    );
    output.push_str("};");

    output
}

fn deserialize_enum(def: &Enum) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "{} ${}FromJson(String value)=>",
        def.name, def.name
    ));
    output.push_str("switch(value){");
    output.push_str(
        &def.values
            .iter()
            .map(|v| format!("'{}'=>{}.{},", v, def.name, v))
            .collect::<Vec<_>>()
            .join(""),
    );
    output.push_str(&format!("_=>throw'Unknown {} value: $value'", def.name));
    output.push_str("};");

    output
}

fn serialize_alias(alias: &Alias) -> String {
    format!(
        "dynamic ${}ToJson({} instance) => {};",
        alias.name,
        alias.name,
        serialize_shape("instance", &alias.def.shape)
    )
}

fn deserialize_alias(alias: &Alias) -> String {
    format!(
        "{} ${}FromJson(dynamic json) => {};",
        alias.name,
        alias.name,
        deserialize_shape("json", &alias.def.shape)
    )
}

fn deserialize_struct(def: &Struct) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "{} ${}FromJson(Map<String,dynamic>json)=>{}(",
        &def.name, &def.name, &def.name
    ));
    output.push_str(
        &def.fields
            .iter()
            .map(|(name, field)| {
                format!(
                    "{}:{}",
                    name,
                    deserialize_shape(&format!("json['{}']", name), &field.shape)
                )
            })
            .collect::<Vec<_>>()
            .join(","),
    );
    output.push_str(");");

    output
}

fn serialize_shape(name: &str, shape: &Shape) -> String {
    match shape {
        Shape::Nullable(inner) => format!(
            "{} == null ? null : {}",
            name,
            serialize_shape(&format!("{} as {}", name, emit_shape(inner)), inner),
        ),
        Shape::Reference(type_name) => {
            format!("${}ToJson({})", type_name, name)
        }
        _ => format!("{}", name),
    }
}

fn deserialize_shape(field_name: &str, shape: &Shape) -> String {
    match shape {
        Shape::Primitive(_) => format!("{} as {}", field_name, emit_shape(shape)),
        Shape::Nullable(inner) => format!(
            "{} == null ? null : {}",
            field_name,
            deserialize_shape(field_name, inner),
        ),
        Shape::List(inner) => format!(
            "({} as List<dynamic>).map((e) => {}).toList()",
            field_name,
            deserialize_shape("e", inner)
        ),
        Shape::Set(inner) => format!(
            "({} as List<dynamic>).map((e) => {}).toSet()",
            field_name,
            deserialize_shape("e", inner)
        ),
        Shape::Map(key, value) => format!(
            "({} as Map<String,dynamic>).map((k,v) => MapEntry({},{}))",
            field_name,
            deserialize_shape("k", key),
            deserialize_shape("v", value),
        ),
        Shape::Reference(name) => format!("${}FromJson({})", name, field_name),
    }
}
